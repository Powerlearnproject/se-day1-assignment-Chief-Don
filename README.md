[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18369053&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications. Software engineers apply engineering principles and knowledge of programming languages to build software solutions for end users.Through continuous investment in technology, companies can reduce costs and offer a better service to their customers.

Identify and describe at least three key milestones in the evolution of software engineering.
Change in requirement with time: With time, the organization’s needs and modus Operandi of working could substantially be changed so in this frequently changing time the tools(software) that they are using need to change to maximize the performance.
Environment change: As the working environment changes the things(tools) that enable us to work in that environment also changes proportionally same happens in the software world as the working environment changes then, the organizations require reintroduction of old software with updated features and functionality to adapt the new environment.
Errors and bugs: As the age of the deployed software within an organization increases their preciseness or impeccability decrease and the efficiency to bear the increasing complexity workload also continually degrades. So, in that case, it becomes necessary to avoid use of obsolete and aged software. All such obsolete Pieces of software need to undergo the evolution process in order to become robust as per the workload complexity of the current environment.  

List and briefly explain the phases of the Software Development Life Cycle.
Stage-1: Planning and Requirement Analysis
Planning is a crucial step in everything, just as in software development. In this same stage, requirement analysis is also performed by the developers of the organization. This is attained from customer inputs, and sales department/market surveys. 

The information from this analysis forms the building blocks of a basic project. The quality of the project is a result of planning. Thus, in this stage, the basic project is designed with all the available information
Stage-2: Defining Requirements
In this stage, all the requirements for the target software are specified. These requirements get approval from customers, market analysts, and stakeholders. 
This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle. 
tage-3: Designing Architecture
SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS). 
Stage-4: Developing Product
At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS. Hence, it is important for the coders to follow the protocols set by the association. Conventional programming tools like compilers, interpreters, debuggers, etc. are also put into use at this stage. Some popular languages like C/C++, Python, Java, etc. are put into use as per the software regulations. 

This DDS is assessed by market analysts and stakeholders. After evaluating all the possible factors, the most practical and logical design is chosen for development.
Stage-5: Product Testing and Integration
After the development of the product, testing of the software is necessary to ensure its smooth execution. Although, minimal testing is conducted at every stage of SDLC. Therefore, at this stage, all the probable flaws are tracked, fixed, and retested. This ensures that the product confronts the quality requirements of SRS. 
Stage-6: Deployment and Maintenance of Products
After detailed testing, the conclusive product is released in phases as per the organization’s strategy. Then it is tested in a real industrial environment. It is important to ensure its smooth performance. If it performs well, the organization sends out the product as a whole. After retrieving beneficial feedback, the company releases it as it is or with auxiliary improvements to make it further helpful for the customers. However, this alone is not enough. Therefore, along with the deployment, the product’s supervision. 

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. Waterfall Model
It is the fundamental model of the software development life cycle. This is a very simple model. The waterfall model is not in practice anymore, but it is the basis for all other SDLC models. Because of its simple structure, the waterfall model is easier to use and provides a tangible output. In the waterfall model, once a phase seems to be completed, it cannot be changed, and due to this less flexible nature, the waterfall model is not in practice anymore. 

2. Agile Model
The agile model in SDLC was mainly designed to adapt to changing requests quickly. The main goal of the Agile model is to facilitate quick project completion. The agile model refers to a group of development processes. These processes have some similar characteristics but also possess certain subtle differences among themselves.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software developers are all kinds of original thinkers and doers behind computer programs. Some developers specialize in a single program or application. However, others may build extensive networks or systems that power other programs.
A Quality Assurance Engineer (QA Engineer) is a key player in the software development and distribution lifecycle. QA engineers ensure every aspect of a product adheres to the organization’s specified quality standards and requirements before a release.
A software project manager leads a team of software developers through the implementation of software projects, making they are completed on time, within scope, and to stakeholder satisfaction.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment or IDE is defined as a software platform that facilitates the creation of other software applications by providing a space to write, compile, and debug code, sometimes with value-adding tools that reduce development efforts.
Version Control Systems is a system that records changes made to a file or a set of files. The system refers to the category of software tools that make it possible for the software team to look after the source code changes whenever needed. The system records all the made changes to a file so a specific version may be rolled if required in the future.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
The rapid pace of technological advancement places considerable pressure on software engineers to stay current. In their day-to-day work, they tackle diverse tasks, such as mastering technology stacks (integrated combinations of programming languages, frameworks, and tools) and leveraging software libraries (pre-written code for common functionalities). Beyond writing and debugging code, successful engineers stand out by adopting continuous learning practices and using agile methodologies to adapt to emerging trends, keeping their skills sharp in an ever-evolving industry.
Software engineers generally work on conceptual projects designed and developed to meet customer and client demands. Even within the most straightforward application or product development cycles, software engineers must understand underlying business concepts to ensure that the required features satisfy end users’ needs.
A shortage of IT resources—or the outright lack of a stable IT infrastructure—constitutes one of the toughest challenges that software engineers face in the modern tech landscape. This may include limited high-performance software engineering tools and computing platforms in addition to inefficient data storage architectures. Software engineers must rely heavily on a robust infrastructure to perform their jobs effectively.

If the necessary hardware and software resources aren’t available or accessible, productivity among software engineering teams may be reduced, affecting a product's or service's overall results.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing
Unit Testing is the first level of testing usually performed by the developers.
In unit testing, a module or component is tested in isolation.
As the testing is limited to a particular module or component, exhaustive testing is possible.
Advantage – Error can be detected at an early stage saving time and money to fix it.
Limitation – Integration issues are not detected in this stage, modules may work perfectly on isolation but can have issues in interfacing between the modules.


Integration Testing
Integration testing is the second level of testing in which we test a group of related modules.
It aims at finding interfacing issues b/w the modules i.e. if the individual units can be integrated into a sub-system correctly.
It is of four types – Big-bang, top-down, bottom-up, and Hybrid.
In big bang integration, all the modules are first required to be completed and then integrated. After integration, testing is carried out on the integrated unit as a whole.

In top-down integration testing, the testing flow starts from top-level modules that are higher in the hierarchy towards the lower-level modules. As there is a possibility that the lower-level modules might not have been developed while beginning with top-level modules.

So, in those cases, stubs are used which are nothing but dummy modules or functions that simulate the functioning of a module by accepting the parameters received by the module and giving an acceptable result.

Bottom-up integration testing is also based on an incremental approach but it starts from lower-level modules, moving upwards to the higher-level modules. Again the higher-level modules might not have been developed by the time lower modules are tested. So, in those cases, drivers are used. These drivers simulate the functionality of higher-level modules in order to test lower-level modules.

Hybrid integration testing is also called the Sandwich integration approach. This approach is a combination of both top-down and bottom-up integration testing. Here, the integration starts from the middle layer, and testing is carried out in both directions, making use of both stubs and drivers, whenever necessary.


System Testing
System Testing is the third level of testing.
It is the level of testing where the complete integrated application is tested as a whole.
It aims at determining if the application conforms to its business requirements.
System testing is carried out in an environment that is very similar to the production environment.


Acceptance Testing
Acceptance testing is the final and one of the most important levels of testing on successful completion of which the application is released to production.
It aims at ensuring that the product meets the specified business requirements within the defined standard of quality.
There are two kinds of acceptance testing- alpha testing and beta testing.
When acceptance testing is carried out by testers or some other internal employees of the organization at the developer’s site it is known as alpha testing.
User acceptance testing done by end-users at the end-user’s site is called beta testing.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is an artificial intelligence (AI) engineering technique that refines large language models (LLMs), with specific prompts and recommended outputs. It also is part of the process of refining input to various generative AI (GenAI) services to generate text or images. Prompt engineering helps generative AI tools create various types of content and digital artifacts, including robotic process automation bots, 3D assets, scripts and robot instructions.

Prompt engineering techniques help tune LLMs for specific use cases, ranging from text-based output to graphic design to cybersecurity. However, prompt engineering for various existing generative AI tools is its most widespread use, because there are far more users of existing tools than developers working on new ones.

Prompt engineering combines elements of logic, coding, art and sometimes additional modifiers, such as adjectives and adverbs to make prompts more specific. The prompt can include natural language text, images or other types of input data. Although the most common generative AI tools can process natural language queries, the same prompt will likely generate different results across AI services and tools. Each tool has its own special modifiers to make it easier to describe the weight of words, styles, perspectives, layout or other properties of the desired output or response.
Prompt engineering is essential for creating better AI-powered services, minimizing biases and getting better results from existing generative AI tools.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
"Write an email to your boss about the project" - This prompt is too vague and doesn't provide any specific details or goals. It's difficult for the AI to understand what kind of email you want to write, and the resulting output may not be what you were hoping for.
"Write an email to your boss about the upcoming AI project"
the improved prompt provides enough details to get to know exactly what is being sought after.
